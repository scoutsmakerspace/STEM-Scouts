/* stem-map-override-widget.js

A Decap CMS custom widget used to curate the STEM badge map.

Stored value shape (object):
{
  action: "include" | "exclude",
  badge_id: "explorers-science-and-technology",
  badge_title: "Science and Technology",
  requirement_ref: "Meteorology 1",
  requirement_text: "Work out ...",
  strength: "strong" | "borderline",
  areas: ["Science", "Engineering"],
  why_stem: "...
  leader_prompts: ["..."]
}

Notes
- Requirement refs are taken from `admin/badges_master.json` (generated by tools).
- We keep value stable so returning to an entry shows selections.
*/

(function () {
  const CMS = window.CMS;
  if (!CMS) return;

  const BADGES_URL = './badges_master.json';

  let badgesCache = null;
  let badgeIndex = new Map(); // badge_id -> badge

  async function loadBadgesMaster() {
    if (badgesCache) return badgesCache;
    const res = await fetch(BADGES_URL, { cache: 'no-store' });
    if (!res.ok) throw new Error('Failed to load badges_master.json');
    badgesCache = await res.json();
    badgeIndex = new Map(badgesCache.map(b => [b.id, b]));
    return badgesCache;
  }

  function h(tag, props, ...children) {
    const el = document.createElement(tag);
    if (props) {
      for (const [k, v] of Object.entries(props)) {
        if (k === 'class') el.className = v;
        else if (k === 'style') Object.assign(el.style, v);
        else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.substring(2).toLowerCase(), v);
        else if (v !== undefined && v !== null) el.setAttribute(k, String(v));
      }
    }
    for (const c of children.flat()) {
      if (c === null || c === undefined) continue;
      el.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
    }
    return el;
  }

  function linesToArray(s) {
    return String(s || '')
      .split(/\r?\n/)
      .map(x => x.trim())
      .filter(Boolean);
  }

  function arrayToLines(a) {
    return Array.isArray(a) ? a.join('\n') : '';
  }

  function parseAreas(s) {
    return String(s || '')
      .split(',')
      .map(x => x.trim())
      .filter(Boolean);
  }

  function areasToString(a) {
    return Array.isArray(a) ? a.join(', ') : '';
  }

  function reqOptionsForBadge(badge) {
    const reqs = (badge && badge.requirements) ? badge.requirements : [];
    return reqs.filter(r => r && (r.kind === 'req' || r.kind === undefined));
  }

  const Control = CMS.registerWidget('stem_map_override', class extends CMS.WidgetControl {
    constructor(props) {
      super(props);
      this.state = {
        ready: false,
        badges: [],
      };
    }

    componentDidMount() {
      loadBadgesMaster()
        .then(badges => this.setState({ ready: true, badges }))
        .catch(err => {
          console.error(err);
          this.setState({ ready: true, badges: [] });
        });
    }

    handleChange(next) {
      this.props.onChange(next);
    }

    render() {
      const value = this.props.value || {};
      const action = value.action || 'include';
      const badgeId = value.badge_id || '';
      const badgeTitle = value.badge_title || '';
      const requirementRef = value.requirement_ref || '';
      const requirementText = value.requirement_text || '';
      const strength = value.strength || 'borderline';
      const whyStem = value.why_stem || '';
      const areas = value.areas || [];
      const leaderPrompts = value.leader_prompts || [];

      const container = h('div', { class: 'stem-map-override', style: { padding: '8px 0' } });

      if (!this.state.ready) {
        container.appendChild(h('div', null, 'Loading badge data…'));
        return container;
      }

      // Action
      const actionSel = h('select', {
        onchange: (e) => {
          const next = { ...value, action: e.target.value };
          this.handleChange(next);
        }
      },
        h('option', { value: 'include' }, 'include'),
        h('option', { value: 'exclude' }, 'exclude')
      );

      // Badge select (datalist style)
      const badgeInputId = `stemBadge_${this.props.forID}`;
      const badgeListId = `stemBadgeList_${this.props.forID}`;

      const badgeInput = h('input', {
        id: badgeInputId,
        list: badgeListId,
        value: badgeTitle,
        placeholder: 'Start typing a badge name…',
        oninput: (e) => {
          const title = e.target.value;
          // try to resolve to a badge id
          const found = this.state.badges.find(b => `${b.badge_name}` === title) ||
                        this.state.badges.find(b => `${b.section_label} — ${b.badge_name}` === title);
          const next = {
            ...value,
            badge_id: found ? found.id : '',
            badge_title: title,
            // reset requirement when badge changes
            requirement_ref: '',
            requirement_text: ''
          };
          this.handleChange(next);
        }
      });

      const badgeDatalist = h('datalist', { id: badgeListId },
        this.state.badges.map(b => h('option', { value: `${b.section_label} — ${b.badge_name}` }))
      );

      // If user selected using the "Section — Name" label, normalise to name
      // (purely cosmetic)
      const resolveBadgeFromTitle = () => {
        if (badgeId) return badgeIndex.get(badgeId);
        const t = (badgeTitle || '').trim();
        // accept either "Name" or "Section — Name"
        let found = this.state.badges.find(b => b.badge_name === t);
        if (!found) {
          found = this.state.badges.find(b => `${b.section_label} — ${b.badge_name}` === t);
        }
        return found;
      };

      const badgeObj = resolveBadgeFromTitle();
      const reqs = badgeObj ? reqOptionsForBadge(badgeObj) : [];

      // Requirement select
      const reqSel = h('select', {
        onchange: (e) => {
          const ref = e.target.value;
          const r = reqs.find(x => x.id === ref);
          const next = {
            ...value,
            badge_id: badgeObj ? badgeObj.id : '',
            badge_title: badgeObj ? `${badgeObj.section_label} — ${badgeObj.badge_name}` : badgeTitle,
            requirement_ref: ref,
            requirement_text: r ? r.text : ''
          };
          this.handleChange(next);
        }
      },
        h('option', { value: '' }, badgeObj ? 'Select a requirement…' : 'Select a badge first…'),
        reqs.map(r => h('option', { value: r.id, selected: r.id === requirementRef }, `${r.id}. ${r.text}`))
      );

      // Strength
      const strengthSel = h('select', {
        onchange: (e) => this.handleChange({ ...value, strength: e.target.value })
      },
        h('option', { value: 'strong', selected: strength === 'strong' }, 'strong'),
        h('option', { value: 'borderline', selected: strength === 'borderline' }, 'borderline')
      );

      // Areas input
      const areasInput = h('input', {
        type: 'text',
        value: areasToString(areas),
        placeholder: 'Comma-separated, e.g. Science, Engineering',
        oninput: (e) => this.handleChange({ ...value, areas: parseAreas(e.target.value) })
      });

      // Why STEM
      const whyArea = h('textarea', {
        rows: '3',
        style: { width: '100%' },
        value: whyStem,
        placeholder: 'Short justification visible on the page…',
        oninput: (e) => this.handleChange({ ...value, why_stem: e.target.value })
      });

      // Leader prompts
      const promptArea = h('textarea', {
        rows: '4',
        style: { width: '100%' },
        value: arrayToLines(leaderPrompts),
        placeholder: 'One prompt per line (hidden behind “Leader prompts”)…',
        oninput: (e) => this.handleChange({ ...value, leader_prompts: linesToArray(e.target.value) })
      });

      // Summary info
      const summary = h('div', { style: { marginTop: '6px', fontSize: '12px', opacity: 0.8 } },
        requirementText ? `Selected: ${requirementRef}. ${requirementText}` : ''
      );

      // Layout
      const grid = h('div', { style: { display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' } },
        h('label', null, h('div', null, 'Action'), actionSel),
        h('label', null, h('div', null, 'Strength (for include)'), strengthSel),
        h('label', { style: { gridColumn: '1 / -1' } }, h('div', null, 'Badge'), badgeInput, badgeDatalist),
        h('label', { style: { gridColumn: '1 / -1' } }, h('div', null, 'Requirement'), reqSel),
        h('label', { style: { gridColumn: '1 / -1' } }, h('div', null, 'Areas (comma-separated)'), areasInput),
        h('label', { style: { gridColumn: '1 / -1' } }, h('div', null, 'Why STEM'), whyArea),
        h('label', { style: { gridColumn: '1 / -1' } }, h('div', null, 'Leader prompts (optional)'), promptArea),
      );

      container.appendChild(grid);
      container.appendChild(summary);

      // If action is exclude, we don't need strength/areas/why/prompts, but we
      // keep them in the object so users can flip action without retyping.

      return container;
    }
  });

  CMS.registerWidget('stem_map_override', Control);
})();
